"""
Data models for LeoForge framework
"""
from typing import List, Optional
from enum import Enum
from datetime import datetime
from dataclasses import dataclass
from pydantic import BaseModel, Field


class ProjectType(str, Enum):
    """Types of Leo projects that can be generated"""
    TOKEN = "token"
    NFT = "nft"
    DEFI = "defi"
    GAME = "game"
    ORACLE = "oracle"
    CUSTOM = "custom"


class CompilationStatus(str, Enum):
    """Status of compilation attempt"""
    SUCCESS = "success"
    ERROR = "error"
    WARNING = "warning"
    TIMEOUT = "timeout"
    UNKNOWN = "unknown"


@dataclass
class UserQuery:
    """User's initial project request"""
    query: str  
    project_type: Optional[ProjectType] = None  
    constraints: List[str] = None
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.constraints is None:
            self.constraints = []
        if self.timestamp is None:
            self.timestamp = datetime.now()


class ArchitectureDesign(BaseModel):
    """Architecture design from the Architect agent - PYDANTIC for agent compatibility"""
    project_name: str  
    project_type: ProjectType  
    description: str  
    features: List[str]
    technical_requirements: List[str]
    data_structures: List[str]
    transitions: List[str]
    security_considerations: List[str]
    admin_features: List[str]
    requires_admin: bool = False


@dataclass
class CodeRequirements:
    """Normalized requirements for code generation"""
    project_name: str
    description: str
    features: List[str]
    architecture: ArchitectureDesign
    version: str = "1.0.0"


class GeneratedCode(BaseModel):
    """Code generated by the CodeGenerator agent - PYDANTIC for agent compatibility"""
    project_name: str
    code: str = ""



class EvaluationResult(BaseModel):
    """Result from the CodeEvaluator agent - PYDANTIC for agent compatibility"""
    is_complete: bool
    has_errors: bool
    missing_features: List[str] = Field(default_factory=list)
    improvements: List[str] = Field(default_factory=list)
    security_issues: List[str] = Field(default_factory=list)
    optimization_suggestions: List[str] = Field(default_factory=list)
    score: float
    needs_iteration: bool = False


@dataclass
class BuildResult:
    """Result from the Builder/Compiler"""
    status: CompilationStatus
    stdout: str = ""
    stderr: str = ""
    warnings: List[str] = None
    errors: List[str] = None
    success: bool = False
    build_time: float = 0.0
    output_files: List[str] = None
    
    def __post_init__(self):
        if self.warnings is None:
            self.warnings = []
        if self.errors is None:
            self.errors = []
        if self.output_files is None:
            self.output_files = []


@dataclass
class IterationResult:
    """Result of a single iteration in the generation workflow"""
    iteration_number: int
    code: GeneratedCode
    evaluation: EvaluationResult
    build: Optional[BuildResult] = None
    success: bool = False
    duration: float = 0.0


@dataclass
class ProjectResult:
    """Final result of the entire project generation"""
    success: bool
    project_name: str
    final_code: Optional[str] = None
    iterations: List[IterationResult] = None
    total_iterations: int = 0
    total_duration: float = 0.0
    error_message: Optional[str] = None
    workspace_path: Optional[str] = None
    
    def __post_init__(self):
        if self.iterations is None:
            self.iterations = []


@dataclass
class ErrorLog:
    """Log entry for a single error occurrence"""
    timestamp: datetime
    iteration_number: int
    error_type: str  # compilation, evaluation, build
    error_message: str
    code_version: str  # Le code qui a causé l'erreur
    context: Optional[str] = None  # Context additionnel
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()


@dataclass
class RunLog:
    """Complete log for a project generation run"""
    run_id: str
    project_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    success: bool = False
    error_logs: List[ErrorLog] = None
    code_versions: List[str] = None  # Toutes les versions de code générées
    resolution_path: List[str] = None  # Le chemin de résolution des erreurs
    
    def __post_init__(self):
        if self.error_logs is None:
            self.error_logs = []
        if self.code_versions is None:
            self.code_versions = []
        if self.resolution_path is None:
            self.resolution_path = []


class RuleType(str, Enum):
    """Types of rules that can be created"""
    ARCHITECT = "architect"
    CODEX = "codex"  # pour le code generator
    GENERAL = "general"


class LeoRule(BaseModel):
    """Rule generated by the RuleEngineer agent"""
    rule_id: str
    rule_type: RuleType
    title: str
    description: str
    pattern: str  # Pattern d'erreur à éviter
    solution: str  # Solution recommandée
    examples: List[str] = Field(default_factory=list)
    priority: int = Field(default=1, ge=1, le=10)  # 1-10, 10 étant le plus important
    tags: List[str] = Field(default_factory=list)
    created_from_errors: List[str] = Field(default_factory=list)  # IDs des erreurs qui ont mené à cette règle


class RuleAnalysis(BaseModel):
    """Analysis result from the RuleEngineer agent"""
    architect_rules: List[LeoRule] = Field(default_factory=list)
    codex_rules: List[LeoRule] = Field(default_factory=list)
    general_observations: List[str] = Field(default_factory=list)
    improvement_suggestions: List[str] = Field(default_factory=list)
    success_patterns: List[str] = Field(default_factory=list)  # Patterns qui ont mené au succès 